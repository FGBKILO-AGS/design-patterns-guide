# UML统一建模语言

## 概述

UML (Unified Modeling Language) 是一种标准化的建模语言，用于软件系统的可视化、规约、构造和文档化。在设计模式的学习和应用中，UML图是理解和表达模式结构的重要工具。

## 1. 类图 (Class Diagram)

类图是最常用的UML图，用于描述系统中类的静态结构和它们之间的关系。

### 1.1 类的表示

#### 基本结构
```
┌─────────────────┐
│    ClassName    │  ← 类名
├─────────────────┤
│   - attribute   │  ← 属性
│   + method()    │  ← 方法
└─────────────────┘
```

#### 三层结构详解
- **第一层：类名**
  - 普通类：正常字体
  - 抽象类：斜体或 `<<abstract>>`
  - 接口：`<<interface>>` 或斜体

- **第二层：属性**
  - 格式：`访问修饰符 属性名: 类型 = 默认值`
  - 示例：`- name: String = ""`

- **第三层：方法**
  - 格式：`访问修饰符 方法名(参数): 返回类型`
  - 示例：`+ getName(): String`

### 1.2 访问修饰符

| 符号 | 访问级别 | 说明 |
|------|----------|------|
| `+` | public | 公有，任何地方都可访问 |
| `-` | private | 私有，只有本类可访问 |
| `#` | protected | 受保护，本类和子类可访问 |
| `~` | package | 包级别，同包内可访问 |

### 1.3 特殊标记

- **静态成员**：下划线表示
  - `+ getInstance(): Singleton` (静态方法)
- **抽象成员**：斜体表示
  - `+ abstractMethod()` (抽象方法)
- **常量**：全大写
  - `+ MAX_SIZE: int = 100`

### 1.4 类间关系

#### 继承/泛化 (Generalization)
```
子类 ────────▷ 父类
```
- **UML官方定义**：泛化是一般化元素和特殊化元素之间的分类关系
- **箭头表示**：空心三角形 + 实线
- **关系含义**：is-a关系，表示子类是父类的一种特殊类型
- **特征**：
  - 子类继承父类的所有属性和方法
  - 子类可以重写父类的方法
  - 子类可以添加自己特有的属性和方法
  - 支持多态性
- **代码体现**：通过extends关键字实现
- **实际示例**：
  - Dog继承Animal（狗是动物的一种）
  - Circle继承Shape（圆形是图形的一种）
  - Student继承Person（学生是人的一种）

#### 实现 (Realization)
```
实现类 ┄┄┄┄┄▷ 接口
```
- **UML官方定义**：实现是规约和实现之间的语义关系
- **箭头表示**：空心三角形 + 虚线
- **关系含义**：类实现接口定义的契约
- **特征**：
  - 类必须实现接口中声明的所有方法
  - 一个类可以实现多个接口
  - 接口定义了类的行为规范
  - 支持多重继承的效果
- **代码体现**：通过implements关键字实现
- **实际示例**：
  - ArrayList实现List接口
  - FileWriter实现Writer接口
  - Thread实现Runnable接口

#### 依赖 (Dependency)
```
客户类 ┄┄┄┄┄> 供应类
```
- **UML官方定义**：依赖是两个模型元素间的语义关系，其中一个元素的变化会影响另一个元素
- **箭头表示**：普通箭头 + 虚线
- **关系含义**：uses-a关系，表示临时性的使用关系
- **特征**：
  - 是最弱的关联关系
  - 通常是临时性的
  - 一个类的改变可能影响另一个类
  - 不涉及属性层面的关联
- **常见形式**：
  - 方法参数：`public void method(ParameterClass param)`
  - 局部变量：`LocalClass local = new LocalClass()`
  - 方法返回值：`public ReturnClass getObject()`
  - 静态方法调用：`UtilClass.staticMethod()`
- **实际示例**：
  - Controller依赖Service（通过方法参数）
  - 工具类的使用（通过静态方法调用）

#### 关联 (Association)
```
类A ────────> 类B
```
- **UML官方定义**：关联是类之间的结构关系，描述了连接的对象集合
- **箭头表示**：普通箭头 + 实线（可以是单向或双向）
- **关系含义**：has-a关系，表示长期性的结构关系
- **特征**：
  - 比依赖关系更强，比聚合关系更弱
  - 通常表现为类的属性
  - 可以是单向或双向关联
  - 具有持久性
- **关联类型**：
  - **单向关联**：只有一个方向的导航
  - **双向关联**：两个方向都可以导航
  - **自关联**：类与自身的关联
- **多重性约束**：
  - 1对1：一个对象关联一个对象
  - 1对多：一个对象关联多个对象
  - 多对多：多个对象关联多个对象
- **实际示例**：
  - Person有Address（人有地址）
  - Order有Customer（订单有客户）
  - Teacher教Student（老师教学生）

#### 聚合 (Aggregation)
```
整体 ◇────────> 部分
```
- **UML官方定义**：聚合是一种特殊的关联，表示整体和部分的关系
- **箭头表示**：空心菱形 + 实线
- **关系含义**：has-a关系，表示弱的"整体-部分"关系
- **特征**：
  - 部分可以独立于整体存在
  - 整体和部分的生命周期不同步
  - 部分可以被多个整体共享
  - 是一种较弱的包含关系
- **生命周期**：
  - 整体消失时，部分可以继续存在
  - 部分可以脱离整体独立存在
  - 部分可以转移到其他整体中
- **代码特征**：
  - 通常通过构造函数参数或setter方法设置
  - 部分对象通常在整体外部创建
- **实际示例**：
  - Department聚合Employee（部门包含员工，员工可以转部门）
  - Team聚合Player（团队包含球员，球员可以转队）
  - Library聚合Book（图书馆包含图书，图书可以转移）

#### 组合 (Composition)
```
整体 ◆────────> 部分
```
- **UML官方定义**：组合是一种强聚合形式，表示整体负责部分的生命周期
- **箭头表示**：实心菱形 + 实线
- **关系含义**：contains-a关系，表示强的"整体-部分"关系
- **特征**：
  - 部分不能独立于整体存在
  - 整体和部分的生命周期同步
  - 部分不能被多个整体共享
  - 是一种强的包含关系
- **生命周期**：
  - 整体创建时创建部分
  - 整体消失时部分也消失
  - 部分不能脱离整体独立存在
- **代码特征**：
  - 部分对象通常在整体内部创建
  - 整体负责部分的创建和销毁
- **实际示例**：
  - House组合Room（房子包含房间，房子拆除房间也消失）
  - Car组合Engine（汽车包含引擎，汽车报废引擎也报废）
  - Document组合Paragraph（文档包含段落，文档删除段落也删除）

#### 关系强度对比
从弱到强的关系强度排序：
1. **依赖** < 2. **关联** < 3. **聚合** < 4. **组合** < 5. **继承**

#### 选择关系类型的判断标准
- **依赖**：临时使用，方法级别的关系
- **关联**：长期关系，属性级别的关系
- **聚合**：整体-部分关系，部分可独立存在
- **组合**：整体-部分关系，部分不可独立存在
- **继承**：is-a关系，类型层次关系

### 1.5 多重性 (Multiplicity)

| 表示 | 含义 |
|------|------|
| `1` | 恰好一个 |
| `0..1` | 零个或一个 |
| `1..*` | 一个或多个 |
| `*` | 零个或多个 |
| `n..m` | n到m个 |

## 2. 时序图 (Sequence Diagram)

时序图用于描述对象间的交互过程，强调消息传递的时间顺序。

### 2.1 基本元素

#### 参与者 (Actor)
```
┌─────────┐
│ :Client │
└─────────┘
    │
    │ (生命线)
    ▼
```

#### 对象 (Object)
```
┌──────────────┐
│ obj:ClassName │
└──────────────┘
        │
        │ (生命线)
        ▼
```

#### 激活框 (Activation Box)
```
    │
    ■ ← 激活框，表示对象处于活动状态
    ■
    │
```

### 2.2 消息类型

#### 同步消息
```
对象A ────────> 对象B
      方法调用
```

#### 异步消息
```
对象A ┄┄┄┄┄> 对象B
      异步调用
```

#### 返回消息
```
对象A <┄┄┄┄┄ 对象B
      返回值
```

#### 自调用
```
对象A ┐
      │ 自调用
      └─>
```

### 2.3 创建和销毁

#### 对象创建
```
创建者 ────────> <<create>> :新对象
```

#### 对象销毁
```
对象 ────────> X
     destroy
```

## 3. 协作图 (Collaboration Diagram)

协作图关注对象间的协作关系，强调对象的组织结构。

### 3.1 基本元素

#### 对象和链接
```
:对象A ────────── :对象B
       链接
```

#### 消息编号
```
:对象A ──1: 消息──> :对象B
       ──2: 消息──> :对象C
```

#### 条件和迭代
```
:对象A ──1[条件]: 消息──> :对象B
       ──2*[i:=1..n]: 消息──> :对象C
```

## 4. 状态图 (State Diagram)

状态图描述对象在生命周期内的状态变化。

### 4.1 基本元素

#### 状态
```
┌─────────────┐
│   状态名    │
├─────────────┤
│ entry/动作  │
│ do/活动     │
│ exit/动作   │
└─────────────┘
```

#### 转换
```
状态A ──事件[守护条件]/动作──> 状态B
```

#### 初始状态和终止状态
```
● ──> 状态A ──> ◉
初始    状态    终止
```

### 4.2 复合状态

```
┌─────────────────────────────┐
│         复合状态            │
│ ┌─────────┐  ┌─────────┐   │
│ │ 子状态A │  │ 子状态B │   │
│ └─────────┘  └─────────┘   │
└─────────────────────────────┘
```

## 5. 活动图 (Activity Diagram)

活动图描述系统的工作流程和业务过程。

### 5.1 基本元素

#### 活动
```
┌─────────────┐
│    活动     │
└─────────────┘
```

#### 决策和合并
```
    ◇ 决策点
   ╱ ╲
  ╱   ╲
 ▼     ▼
活动A  活动B
 │     │
 ▼     ▼
  ╲   ╱
   ╲ ╱
    ◇ 合并点
```

#### 分叉和汇合
```
    │
    ■ 分叉
   ╱│╲
  ╱ │ ╲
 ▼  ▼  ▼
活动A 活动B 活动C
 │  │  │
 ▼  ▼  ▼
  ╲ │ ╱
   ╲│╱
    ■ 汇合
    │
```

### 5.2 泳道 (Swimlane)

```
┌─────────┬─────────┬─────────┐
│  角色A  │  角色B  │  角色C  │
├─────────┼─────────┼─────────┤
│ ┌─────┐ │         │         │
│ │活动1│ │         │         │
│ └─────┘ │         │         │
│    │    │         │         │
│    ▼    │         │         │
│         │ ┌─────┐ │         │
│         │ │活动2│ │         │
│         │ └─────┘ │         │
└─────────┴─────────┴─────────┘
```

## 6. UML在设计模式中的应用

### 6.1 模式结构图

每个设计模式都有标准的UML类图表示：

#### 单例模式示例
```
┌─────────────────┐
│   Singleton     │
├─────────────────┤
│ - instance      │
├─────────────────┤
│ - Singleton()   │
│ + getInstance() │
└─────────────────┘
```

#### 观察者模式示例
```
┌─────────────┐         ┌─────────────┐
│   Subject   │◇────────│  Observer   │
├─────────────┤         ├─────────────┤
│ + attach()  │         │ + update()  │
│ + detach()  │         └─────────────┘
│ + notify()  │                △
└─────────────┘                │
       △                       │
       │                       │
┌─────────────┐         ┌─────────────┐
│ConcreteSubj │         │ConcreteObs  │
├─────────────┤         ├─────────────┤
│ + getState()│         │ + update()  │
│ + setState()│         └─────────────┘
└─────────────┘
```

### 6.2 行为描述图

使用时序图描述模式的动态行为：

#### 观察者模式时序图
```
Client  ConcreteSubject  ConcreteObserver
  │           │               │
  │ setState()│               │
  ├──────────>│               │
  │           │ notify()      │
  │           ├──────────────>│
  │           │               │ update()
  │           │<──────────────┤
  │           │ getState()    │
  │           ├──────────────>│
  │           │               │
```

## 7. UML工具推荐

### 在线工具
- **PlantUML**：文本驱动的UML工具
- **Draw.io**：免费的在线绘图工具
- **Lucidchart**：专业的图表工具

### 桌面工具
- **Enterprise Architect**：专业UML建模工具
- **Visual Paradigm**：功能全面的建模工具
- **StarUML**：开源UML工具

### IDE集成
- **IntelliJ IDEA**：内置UML图生成
- **Eclipse**：UML插件支持
- **Visual Studio**：类图生成功能

## 总结

UML是理解和表达设计模式的重要工具。掌握UML的基本图形和符号，能够帮助我们：

1. **更好地理解设计模式的结构**
2. **清晰地表达设计思想**
3. **有效地进行团队沟通**
4. **准确地记录系统设计**

在学习设计模式时，建议：
- 重点掌握类图和时序图
- 理解各种关系的含义和使用场景
- 练习绘制常见模式的UML图
- 学会从UML图理解代码结构