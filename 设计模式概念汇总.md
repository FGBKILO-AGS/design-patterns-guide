# 设计模式完整概念汇总

## 第一部分：基础理论概念

### 1. 设计模式基本概念

#### 1.1 核心定义

##### 设计模式 (Design Pattern)
- **GoF原定义**：*"设计模式是在特定环境下人们解决某类重复出现问题的一套成功或有效的解决方案。"*
- **扩展定义**：在特定环境下，为解决某一通用软件设计问题提供的一套定制的解决方案
- **本质**：可复用的面向对象软件设计经验

##### 模式语言 (Pattern Language)
- **Alexander原定义**：*"每个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。"*
- **软件领域定义**：描述设计问题、解决方案和效果的标准化语言
- **作用**：为设计者提供共同的词汇和交流方式

##### 可复用性 (Reusability)
- **定义**：模式可以在不同的软件系统中重复使用
- **层次**：设计复用比代码复用更高层次
- **价值**：避免重新发明轮子，提高开发效率

##### 最佳实践 (Best Practice)
- **定义**：经过验证的、优秀的设计经验总结
- **特征**：经过时间检验，被广泛认可和应用
- **来源**：专家经验的结晶和总结

#### 1.2 模式要素
- **模式名称**：简洁描述设计问题、解决方案和效果的词汇
- **问题**：描述何时使用该模式，包括设计问题和问题的前因后果
- **解决方案**：描述设计的组成成分、关系、职责和协作方式
- **效果**：使用模式的结果和权衡，包括对灵活性、扩展性的影响

#### 1.3 模式分类
- **创建型模式**：处理对象创建机制，将对象的创建和使用分离
- **结构型模式**：处理对象和类的组合，形成更大的结构
- **行为型模式**：处理对象间的通信和职责分配

### 2. UML建模概念

#### 2.1 类图概念
- **类**：具有相同属性和方法的对象集合的抽象
- **属性**：类的数据成员，描述对象的状态
- **方法**：类的函数成员，描述对象的行为
- **访问修饰符**：控制类成员的可见性（public、private、protected、package）
- **静态成员**：属于类而不是实例的成员
- **抽象类**：不能实例化的类，通常包含抽象方法
- **接口**：定义类必须实现的方法契约

#### 2.2 类间关系概念
- **继承/泛化**：子类继承父类的属性和方法，is-a关系
- **实现**：类实现接口定义的方法契约
- **依赖**：一个类使用另一个类，临时性的uses-a关系
- **关联**：类之间的结构化关系，长期性的has-a关系
- **聚合**：整体-部分关系，部分可以独立于整体存在
- **组合**：强整体-部分关系，部分不能独立于整体存在
- **多重性**：关系中对象的数量约束

#### 2.3 动态图概念
- **时序图**：按时间顺序显示对象间的交互
- **协作图**：强调对象间的组织结构和消息传递
- **状态图**：描述对象在生命周期内的状态变化
- **活动图**：描述系统的工作流程和业务过程

### 3. 面向对象设计原则概念

#### 3.1 SOLID原则
- **单一职责原则(SRP)**：一个类应该只有一个引起变化的原因
- **开放-封闭原则(OCP)**：对扩展开放，对修改封闭
- **里氏替换原则(LSP)**：子类对象应该能够替换父类对象
- **接口隔离原则(ISP)**：客户端不应该依赖不需要的接口
- **依赖倒置原则(DIP)**：依赖于抽象，而不是具体实现

#### 3.2 其他重要原则
- **迪米特法则(LoD)**：一个对象应该对其他对象有最少的了解
- **合成/聚合复用原则(CARP)**：优先使用组合而不是继承来实现复用

## 第二部分：创建型模式概念

### 1. 单例模式 (Singleton)

#### 核心概念
- **单例**：确保一个类只有一个实例，并提供全局访问点
- **实例控制**：控制类的实例化过程
- **全局访问**：提供访问唯一实例的全局方法
- **延迟初始化**：在需要时才创建实例

#### 实现概念
- **饿汉式**：类加载时就创建实例
- **懒汉式**：第一次使用时才创建实例
- **双重检查锁定**：线程安全的懒汉式实现
- **静态内部类**：利用类加载机制保证线程安全
- **枚举实现**：最简洁的单例实现方式

#### 相关概念
- **线程安全**：多线程环境下的正确性
- **序列化安全**：序列化后不破坏单例特性
- **反射安全**：防止通过反射创建多个实例

### 2. 工厂方法模式 (Factory Method)

#### 核心概念
- **工厂方法**：定义创建对象的接口，让子类决定实例化哪个类
- **产品**：工厂创建的对象
- **创建者**：包含工厂方法的类
- **延迟实例化**：将对象创建延迟到子类

#### 参与者概念
- **抽象产品**：定义产品的接口
- **具体产品**：实现产品接口的具体类
- **抽象创建者**：声明工厂方法的抽象类
- **具体创建者**：实现工厂方法的具体类

#### 相关概念
- **简单工厂**：用一个类来创建所有产品
- **参数化工厂**：根据参数决定创建哪种产品
- **泛型工厂**：使用泛型的工厂实现

### 3. 抽象工厂模式 (Abstract Factory)

#### 核心概念
- **抽象工厂**：提供创建一系列相关对象的接口
- **产品族**：一组相关的产品对象
- **产品等级结构**：产品的继承层次
- **产品一致性**：确保创建的产品属于同一族

#### 参与者概念
- **抽象工厂**：声明创建产品族的接口
- **具体工厂**：实现创建具体产品族的方法
- **抽象产品**：声明产品的接口
- **具体产品**：实现产品接口的具体类

### 4. 建造者模式 (Builder)

#### 核心概念
- **建造者**：负责构造复杂对象的各个部分
- **指挥者**：控制构造过程
- **产品**：被构造的复杂对象
- **分步构造**：逐步构建复杂对象

#### 实现概念
- **传统建造者**：使用指挥者控制构造过程
- **链式建造者**：支持方法链式调用
- **静态内部类建造者**：常见的Java实现方式
- **注解驱动建造者**：通过注解自动生成建造者

### 5. 原型模式 (Prototype)

#### 核心概念
- **原型**：用于创建对象的样板
- **克隆**：通过复制现有对象创建新对象
- **原型管理器**：管理原型对象的注册表

#### 克隆概念
- **浅拷贝**：只复制对象的基本类型字段
- **深拷贝**：递归复制对象的所有字段
- **序列化克隆**：通过序列化实现深拷贝
- **手动克隆**：自定义克隆逻辑

## 第三部分：结构型模式概念

### 1. 适配器模式 (Adapter)

#### 核心概念
- **适配器**：将一个接口转换成客户期望的另一个接口
- **目标接口**：客户端期望的接口
- **适配者**：需要被适配的现有类
- **接口转换**：不兼容接口的转换

#### 实现概念
- **类适配器**：通过继承实现适配
- **对象适配器**：通过组合实现适配
- **双向适配器**：支持双向转换的适配器
- **缺省适配器**：提供接口默认实现的适配器

### 2. 桥接模式 (Bridge)

#### 核心概念
- **桥接**：将抽象与实现分离，使它们可以独立变化
- **抽象**：定义抽象接口
- **实现**：定义实现接口
- **分离变化**：将两个独立变化的维度分离

#### 参与者概念
- **抽象类**：定义抽象接口，维护实现对象的引用
- **扩展抽象类**：扩展抽象接口
- **实现接口**：定义实现类的接口
- **具体实现类**：实现具体的实现接口

### 3. 组合模式 (Composite)

#### 核心概念
- **组合**：将对象组合成树形结构表示部分-整体层次
- **组件**：组合中对象的统一接口
- **叶子**：组合中的叶子节点
- **容器**：组合中的容器节点
- **递归结构**：树形结构的递归特性

#### 实现概念
- **透明方式**：组件接口包含所有子组件管理方法
- **安全方式**：组件接口只包含公共方法
- **树形遍历**：遍历组合结构的方法

### 4. 装饰器模式 (Decorator)

#### 核心概念
- **装饰器**：动态地给对象添加额外的职责
- **组件**：定义对象的接口
- **装饰**：在不改变接口的前提下扩展功能
- **装饰链**：多个装饰器的组合

#### 参与者概念
- **组件接口**：定义对象的接口
- **具体组件**：实现组件接口的基本对象
- **装饰器**：维护组件引用并实现组件接口
- **具体装饰器**：实现具体的装饰功能

### 5. 外观模式 (Facade)

#### 核心概念
- **外观**：为子系统提供统一的高层接口
- **子系统**：实现具体功能的类集合
- **简化接口**：隐藏子系统的复杂性
- **解耦**：客户端与子系统的解耦

#### 实现概念
- **简单外观**：提供简单的统一接口
- **复杂外观**：提供多个层次的接口
- **抽象外观**：定义外观的抽象接口

### 6. 享元模式 (Flyweight)

#### 核心概念
- **享元**：通过共享技术支持大量细粒度对象
- **内部状态**：可以共享的状态信息
- **外部状态**：不可共享的状态信息
- **享元工厂**：管理享元对象的创建和共享

#### 参与者概念
- **享元接口**：定义享元对象的接口
- **具体享元**：实现享元接口的可共享对象
- **非共享享元**：不需要共享的享元对象
- **享元工厂**：创建和管理享元对象

### 7. 代理模式 (Proxy)

#### 核心概念
- **代理**：为其他对象提供代理以控制对这个对象的访问
- **真实主题**：代理所代表的真实对象
- **代理控制**：控制对真实对象的访问

#### 代理类型概念
- **远程代理**：为远程对象提供本地代表
- **虚拟代理**：延迟创建开销大的对象
- **保护代理**：控制对原始对象的访问权限
- **智能引用代理**：提供比简单指针更多的功能
- **缓存代理**：为开销大的运算结果提供暂时存储

#### 实现概念
- **静态代理**：编译时确定代理关系
- **动态代理**：运行时动态创建代理对象
- **JDK动态代理**：基于接口的动态代理
- **CGLIB代理**：基于继承的动态代理

## 第四部分：行为型模式概念

### 1. 责任链模式 (Chain of Responsibility)

#### 核心概念
- **责任链**：将请求的发送者和接收者解耦
- **处理者**：处理请求的对象
- **请求传递**：沿着链传递请求直到有对象处理它
- **动态链**：可以动态改变链的结构

#### 实现概念
- **纯的责任链**：请求只能被一个处理者处理
- **不纯的责任链**：请求可以被多个处理者处理
- **链的构建**：如何构建和管理责任链

### 2. 命令模式 (Command)

#### 核心概念
- **命令**：将请求封装成对象
- **接收者**：执行命令的对象
- **调用者**：发出命令的对象
- **命令队列**：存储命令的队列

#### 参与者概念
- **命令接口**：定义执行命令的接口
- **具体命令**：实现命令接口的具体类
- **接收者**：知道如何实施与执行请求相关的操作
- **调用者**：要求命令执行请求

#### 高级概念
- **宏命令**：组合多个命令的复合命令
- **撤销操作**：支持命令的撤销和重做
- **命令日志**：记录命令执行历史

### 3. 解释器模式 (Interpreter)

#### 核心概念
- **解释器**：为语言定义文法表示，并定义解释器解释语言中的句子
- **抽象语法树**：表示语言语法结构的树
- **文法规则**：定义语言的语法规则
- **上下文**：包含解释器之外的全局信息

#### 参与者概念
- **抽象表达式**：声明抽象的解释操作
- **终结符表达式**：实现文法中终结符相关的解释操作
- **非终结符表达式**：实现文法中非终结符相关的解释操作
- **环境**：包含解释器之外的全局信息

### 4. 迭代器模式 (Iterator)

#### 核心概念
- **迭代器**：提供顺序访问聚合对象元素的方法
- **聚合对象**：包含多个元素的对象
- **遍历**：按某种顺序访问聚合对象的元素
- **封装遍历**：将遍历算法封装在迭代器中

#### 参与者概念
- **迭代器接口**：定义访问和遍历元素的接口
- **具体迭代器**：实现迭代器接口
- **聚合接口**：定义创建迭代器的接口
- **具体聚合**：实现创建迭代器的接口

#### 实现概念
- **内部迭代器**：由聚合对象控制迭代过程
- **外部迭代器**：由客户端控制迭代过程
- **健壮性迭代器**：在迭代过程中可以安全地修改聚合对象

### 5. 中介者模式 (Mediator)

#### 核心概念
- **中介者**：定义对象间交互的封装
- **同事类**：相互交互的对象
- **松耦合**：对象间不直接引用，通过中介者交互
- **集中控制**：将交互逻辑集中在中介者中

#### 参与者概念
- **中介者接口**：定义同事对象交互的接口
- **具体中介者**：实现中介者接口，协调同事对象
- **同事类**：需要与其他对象交互的类

### 6. 备忘录模式 (Memento)

#### 核心概念
- **备忘录**：在不破坏封装的前提下捕获对象的内部状态
- **发起人**：创建备忘录的对象
- **管理者**：负责保存备忘录的对象
- **状态恢复**：从备忘录中恢复对象状态

#### 参与者概念
- **发起人**：创建备忘录来记录当前时刻的内部状态
- **备忘录**：存储发起人的内部状态
- **管理者**：负责保存备忘录，不能对备忘录的内容进行操作

#### 实现概念
- **白盒实现**：备忘录的接口提供宽接口
- **黑盒实现**：备忘录的接口不提供任何方法
- **多重检查点**：支持多个状态的保存和恢复

### 7. 观察者模式 (Observer)

#### 核心概念
- **观察者**：定义对象间一对多的依赖关系
- **主题**：被观察的对象
- **通知机制**：主题状态改变时通知所有观察者
- **发布-订阅**：观察者模式的另一种称呼

#### 参与者概念
- **主题接口**：定义注册、删除和通知观察者的接口
- **具体主题**：实现主题接口，维护观察者列表
- **观察者接口**：定义更新接口
- **具体观察者**：实现观察者接口

#### 实现概念
- **推模型**：主题主动推送信息给观察者
- **拉模型**：观察者主动从主题拉取信息
- **事件委托**：基于事件的观察者实现

### 8. 状态模式 (State)

#### 核心概念
- **状态**：允许对象在内部状态改变时改变行为
- **状态转换**：从一个状态转换到另一个状态
- **状态封装**：将状态相关的行为封装在状态类中
- **状态机**：状态模式实现的状态机

#### 参与者概念
- **环境**：维护当前状态的引用
- **状态接口**：定义状态的接口
- **具体状态**：实现特定状态的行为

#### 相关概念
- **状态转换表**：描述状态转换规则的表格
- **状态机实现**：基于状态模式的状态机实现

### 9. 策略模式 (Strategy)

#### 核心概念
- **策略**：定义算法族，封装每个算法，使它们可以互相替换
- **算法封装**：将算法封装在独立的类中
- **算法切换**：可以在运行时切换算法
- **算法独立**：算法的变化独立于使用算法的客户

#### 参与者概念
- **策略接口**：定义所有具体策略的公共接口
- **具体策略**：实现策略接口的具体算法
- **环境**：维护策略对象的引用

#### 实现概念
- **简单策略**：基本的策略模式实现
- **策略工厂**：结合工厂模式创建策略
- **策略枚举**：使用枚举实现策略模式

### 10. 模板方法模式 (Template Method)

#### 核心概念
- **模板方法**：定义算法骨架，延迟部分步骤到子类
- **算法骨架**：算法的基本结构和流程
- **步骤延迟**：将可变的步骤延迟到子类实现
- **控制反转**：父类控制算法流程，子类实现具体步骤

#### 方法类型概念
- **模板方法**：定义算法骨架的方法
- **基本方法**：实现算法步骤的方法
- **钩子方法**：提供默认行为或空实现的方法
- **抽象方法**：必须由子类实现的方法

### 11. 访问者模式 (Visitor)

#### 核心概念
- **访问者**：表示作用于对象结构中元素的操作
- **元素**：被访问的对象
- **双分派**：根据访问者和元素的类型确定执行的操作
- **操作分离**：将操作从对象结构中分离出来

#### 参与者概念
- **访问者接口**：声明访问具体元素的方法
- **具体访问者**：实现访问者接口
- **元素接口**：定义接受访问者的接口
- **具体元素**：实现元素接口
- **对象结构**：包含元素的容器

## 第五部分：高级主题概念

### 1. 模式组合概念

#### 组合原则
- **模式协作**：多个模式协同工作解决复杂问题
- **模式冲突**：不同模式之间可能存在的冲突
- **模式选择**：在多个可选模式中选择最合适的

#### 常见组合
- **工厂+单例**：确保工厂类的唯一性
- **观察者+中介者**：复杂的对象间通信
- **策略+工厂**：动态选择和创建策略
- **装饰器+组合**：灵活的对象结构扩展

### 2. 架构模式概念

#### MVC架构概念
- **模型(Model)**：数据和业务逻辑
- **视图(View)**：用户界面
- **控制器(Controller)**：处理用户输入
- **分离关注点**：将不同职责分离到不同组件

#### 分层架构概念
- **表示层**：用户界面层
- **业务层**：业务逻辑层
- **数据层**：数据访问层
- **层间依赖**：上层依赖下层，下层不依赖上层

### 3. 企业级模式概念

#### 领域驱动设计概念
- **实体(Entity)**：有唯一标识的对象
- **值对象(Value Object)**：没有唯一标识的对象
- **聚合(Aggregate)**：相关对象的集合
- **仓储(Repository)**：封装数据访问的接口
- **领域服务(Domain Service)**：不属于任何实体的业务逻辑

#### 数据访问模式概念
- **活动记录(Active Record)**：对象包含数据和行为
- **数据映射器(Data Mapper)**：分离对象和数据库
- **表数据网关(Table Data Gateway)**：封装表访问逻辑
- **行数据网关(Row Data Gateway)**：封装行访问逻辑

### 4. 并发模式概念

#### 线程安全概念
- **不可变对象**：状态不可改变的对象
- **线程特定存储**：每个线程独有的存储空间
- **双重检查锁定**：线程安全的延迟初始化

#### 异步模式概念
- **Future/Promise**：异步操作的结果占位符
- **回调模式**：异步操作完成时的回调机制
- **反应式模式**：基于数据流的异步编程模式

### 5. 分布式模式概念

#### 微服务模式概念
- **服务发现**：动态发现服务位置的机制
- **断路器**：防止级联故障的保护机制
- **舱壁隔离**：隔离不同资源避免相互影响
- **超时模式**：设置操作超时避免无限等待

#### 消息模式概念
- **发布-订阅**：消息的发布和订阅机制
- **请求-响应**：同步的消息交互模式
- **消息路由**：根据规则路由消息的机制

### 6. 函数式编程模式概念

#### 高阶函数概念
- **函数作为参数**：将函数作为参数传递
- **函数作为返回值**：函数返回另一个函数
- **函数组合**：将多个函数组合成新函数

#### Monad概念
- **Maybe/Optional**：处理可能为空的值
- **Either**：处理可能失败的操作
- **IO Monad**：处理副作用的操作

### 7. 反模式概念

#### 常见反模式
- **God Object**：承担过多职责的巨大对象
- **Spaghetti Code**：结构混乱难以维护的代码
- **Copy and Paste Programming**：通过复制粘贴编程
- **Golden Hammer**：过度使用熟悉的技术

#### 代码异味概念
- **长方法**：过长的方法
- **大类**：过大的类
- **重复代码**：相同或相似的代码片段
- **数据泥团**：总是一起出现的数据项

### 8. 实践指导概念

#### 设计决策概念
- **问题识别**：识别设计问题的能力
- **模式选择**：选择合适模式的标准
- **权衡分析**：分析不同方案的优缺点
- **重构时机**：何时进行设计重构

#### 质量属性概念
- **可维护性**：代码易于理解和修改
- **可扩展性**：系统易于扩展新功能
- **可复用性**：代码可以在不同场景复用
- **可测试性**：代码易于编写测试

#### 开发实践概念
- **渐进式设计**：逐步改进设计
- **重构到模式**：通过重构应用模式
- **测试驱动设计**：通过测试驱动设计
- **代码审查**：通过审查提高代码质量

## 总结

这份概念汇总涵盖了设计模式学习的所有重要概念，从基础理论到高级应用，从经典模式到现代实践。每个概念都是理解和应用设计模式的重要基石。

学习建议：
1. **循序渐进**：从基础概念开始，逐步深入
2. **理论实践结合**：理解概念的同时动手实践
3. **对比分析**：比较相似概念的异同
4. **场景应用**：在实际项目中应用这些概念
5. **持续学习**：设计模式是不断发展的领域