# 设计模式完整概念汇总（含原定义）

## 第一部分：基础理论概念

### 1. 设计模式基本概念

#### 1.1 核心定义

##### 设计模式 (Design Pattern)
- **GoF原定义**：*"设计模式是在特定环境下人们解决某类重复出现问题的一套成功或有效的解决方案。"*
- **完整定义**：*"设计模式使人们可以更加简单方便地复用成功的设计和体系结构。将已证实的技术表述成设计模式也会使新系统开发者更加容易理解其设计思路。"*
- **扩展定义**：在特定环境下，为解决某一通用软件设计问题提供的一套定制的解决方案
- **本质**：可复用的面向对象软件设计经验

##### 模式语言 (Pattern Language)
- **Alexander原定义**：*"每个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。"*
- **软件领域定义**：描述设计问题、解决方案和效果的标准化语言
- **作用**：为设计者提供共同的词汇和交流方式

##### 可复用性 (Reusability)
- **定义**：模式可以在不同的软件系统中重复使用
- **GoF观点**：*"设计模式的目的是记录设计经验，使其能够被重复使用。"*
- **层次**：设计复用比代码复用更高层次
- **价值**：避免重新发明轮子，提高开发效率

##### 最佳实践 (Best Practice)
- **定义**：经过验证的、优秀的设计经验总结
- **特征**：经过时间检验，被广泛认可和应用
- **来源**：专家经验的结晶和总结

#### 1.2 模式要素

##### 模式名称 (Pattern Name)
- **GoF原定义**：*"模式名称是一个助记名，它用一两个词来描述模式的问题、解决方案和效果。"*
- **作用**：*"命名一个新的模式会立即增加我们的设计词汇。设计模式允许我们在较高的抽象层次上进行设计。"*
- **重要性**：便于交流和文档化

##### 问题 (Problem)
- **GoF原定义**：*"问题描述了应该在何时使用模式。它解释了设计问题和问题存在的前因后果。"*
- **包含内容**：设计问题的描述、问题产生的前因后果、必须满足的约束条件
- **目的**：明确模式的适用场景

##### 解决方案 (Solution)
- **GoF原定义**：*"解决方案描述了设计的组成成分，它们的相互关系及各自的职责和协作方式。"*
- **特点**：抽象的描述，不是具体实现；可以应用于多种不同情况
- **内容**：提供设计问题的通用解决方案

##### 效果 (Consequences)
- **GoF原定义**：*"效果描述了模式应用的效果及使用模式应权衡的问题。"*
- **包含内容**：对系统灵活性、扩展性、可移植性的影响；实现时需要考虑的问题；使用模式的代价和收益
- **价值**：帮助理解和评估模式

#### 1.3 模式分类

##### 创建型模式 (Creational Patterns)
- **GoF原定义**：*"创建型模式抽象了实例化过程。它们帮助一个系统独立于如何创建、组合和表示它的那些对象。"*
- **核心思想**：将对象的创建和使用分离
- **包含模式**：单例、工厂方法、抽象工厂、建造者、原型

##### 结构型模式 (Structural Patterns)
- **GoF原定义**：*"结构型模式涉及到如何组合类和对象以获得更大的结构。"*
- **目的**：描述如何将类或对象结合在一起形成更大的结构
- **包含模式**：适配器、桥接、组合、装饰器、外观、享元、代理

##### 行为型模式 (Behavioral Patterns)
- **GoF原定义**：*"行为模式涉及到算法和对象间职责的分配。"*
- **关注点**：对象间的通信和控制流
- **包含模式**：责任链、命令、解释器、迭代器、中介者、备忘录、观察者、状态、策略、模板方法、访问者

### 2. UML建模概念

#### 2.1 类图概念

##### 类 (Class)
- **UML定义**：*"类是具有相同属性、操作、关系和语义的对象的集合。"*
- **作用**：描述对象的结构和行为
- **表示**：矩形框分为三部分：类名、属性、方法

##### 属性 (Attribute)
- **UML定义**：*"属性是类的命名特性，描述了值的范围。"*
- **格式**：`可见性 名称: 类型 = 默认值`
- **作用**：描述对象的状态

##### 方法 (Method)
- **UML定义**：*"方法是类的行为特征的实现。"*
- **格式**：`可见性 名称(参数列表): 返回类型`
- **作用**：描述对象的行为

##### 访问修饰符 (Visibility)
- **public (+)**：*"公有的，对所有类可见"*
- **private (-)**：*"私有的，只对本类可见"*
- **protected (#)**：*"受保护的，对本类和子类可见"*
- **package (~)**：*"包级别的，对同一包内的类可见"*

#### 2.2 类间关系概念

##### 继承/泛化 (Generalization)
- **UML定义**：*"泛化是一般化元素和特殊化元素之间的分类关系。"*
- **含义**：is-a关系，子类继承父类的属性和方法
- **表示**：空心三角形 + 实线

##### 实现 (Realization)
- **UML定义**：*"实现是规约和实现之间的语义关系。"*
- **含义**：类实现接口定义的方法契约
- **表示**：空心三角形 + 虚线

##### 依赖 (Dependency)
- **UML定义**：*"依赖是两个模型元素间的语义关系，其中一个元素的变化会影响另一个元素。"*
- **含义**：uses-a关系，临时性关联
- **表示**：普通箭头 + 虚线

##### 关联 (Association)
- **UML定义**：*"关联是类之间的结构关系，描述了连接的对象集合。"*
- **含义**：has-a关系，长期性关联
- **表示**：普通箭头 + 实线

##### 聚合 (Aggregation)
- **UML定义**：*"聚合是一种特殊的关联，表示整体和部分的关系。"*
- **含义**：整体-部分关系，部分可以独立于整体存在
- **表示**：空心菱形 + 实线

##### 组合 (Composition)
- **UML定义**：*"组合是一种强聚合形式，表示整体负责部分的生命周期。"*
- **含义**：强整体-部分关系，部分不能独立于整体存在
- **表示**：实心菱形 + 实线

### 3. 面向对象设计原则概念

#### 3.1 SOLID原则

##### 单一职责原则 (Single Responsibility Principle, SRP)
- **Robert Martin原定义**：*"一个类应该只有一个引起它变化的原因。"*
- **扩展定义**：*"就一个类而言，应该仅有一个引起它变化的原因。"*
- **核心思想**：每个类应该只负责一项职责
- **目的**：降低类的复杂度，提高可维护性

##### 开放-封闭原则 (Open-Closed Principle, OCP)
- **Bertrand Meyer原定义**：*"软件实体应该对扩展开放，对修改封闭。"*
- **完整表述**：*"软件实体（类、模块、函数等）应该对扩展开放，对修改封闭。"*
- **核心思想**：通过扩展而不是修改来应对变化
- **实现方式**：抽象化是关键

##### 里氏替换原则 (Liskov Substitution Principle, LSP)
- **Barbara Liskov原定义**：*"子类型必须能够替换掉它们的基类型。"*
- **正式定义**：*"如果对每一个类型为T1的对象o1，都有类型为T2的对象o2，使得以T1定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变化，那么类型T2是类型T1的子类型。"*
- **简化理解**：子类对象应该能够替换父类对象被使用

##### 接口隔离原则 (Interface Segregation Principle, ISP)
- **Robert Martin原定义**：*"客户端不应该依赖它不需要的接口。"*
- **完整表述**：*"不应该强迫客户依赖于它们不用的方法。"*
- **核心思想**：使用多个专门的接口，而不是单一的总接口

##### 依赖倒置原则 (Dependency Inversion Principle, DIP)
- **Robert Martin原定义**：*"高层模块不应该依赖低层模块，两者都应该依赖抽象。抽象不应该依赖细节，细节应该依赖抽象。"*
- **两个要点**：
  1. 高层模块不应该依赖低层模块，两者都应该依赖抽象
  2. 抽象不应该依赖细节，细节应该依赖抽象

#### 3.2 其他重要原则

##### 迪米特法则 (Law of Demeter, LoD)
- **原始定义**：*"只与你的直接朋友交谈，不要跟陌生人说话。"*
- **正式定义**：*"一个对象应该对其他对象保持最少的了解。"*
- **别名**：最少知识原则 (Principle of Least Knowledge)

##### 合成/聚合复用原则 (Composite/Aggregate Reuse Principle, CARP)
- **定义**：*"尽量使用合成/聚合，尽量不要使用类继承。"*
- **核心思想**：优先使用对象组合，而不是继承来达到复用的目的
- **别名**：组合复用原则

## 第二部分：创建型模式概念

### 1. 单例模式 (Singleton)

#### 核心概念

##### 单例模式定义
- **GoF原定义**：*"保证一个类仅有一个实例，并提供一个访问它的全局访问点。"*
- **意图**：*"保证一个类只有一个实例，并提供一个访问它的全局访问点。"*
- **核心**：控制实例数量，提供全局访问

##### 实例控制 (Instance Control)
- **定义**：控制类的实例化过程，确保只创建一个实例
- **机制**：私有构造函数 + 静态实例变量 + 静态访问方法

##### 全局访问点 (Global Access Point)
- **定义**：提供访问唯一实例的全局方法
- **实现**：通常是静态方法 getInstance()

##### 延迟初始化 (Lazy Initialization)
- **定义**：在需要时才创建实例，而不是在类加载时创建
- **优点**：节省内存，提高启动速度
- **缺点**：需要考虑线程安全问题

#### 实现概念

##### 饿汉式 (Eager Initialization)
- **定义**：类加载时就创建实例
- **特点**：线程安全，但可能浪费内存
- **适用场景**：实例必定会被使用的情况

##### 懒汉式 (Lazy Initialization)
- **定义**：第一次使用时才创建实例
- **特点**：节省内存，但需要处理线程安全
- **适用场景**：实例可能不会被使用的情况

##### 双重检查锁定 (Double-Checked Locking)
- **定义**：在懒汉式基础上，使用双重检查来保证线程安全
- **关键**：volatile关键字防止指令重排序
- **优点**：既保证线程安全又保证性能

##### 静态内部类 (Static Inner Class)
- **定义**：利用类加载机制保证线程安全的懒汉式实现
- **原理**：JVM的类加载机制保证线程安全
- **优点**：延迟加载且线程安全

##### 枚举实现 (Enum Singleton)
- **Joshua Bloch观点**：*"单元素的枚举类型已经成为实现Singleton的最佳方法。"*
- **优点**：简洁、线程安全、防止反射和序列化攻击
- **缺点**：不支持延迟加载

### 2. 工厂方法模式 (Factory Method)

#### 核心概念

##### 工厂方法模式定义
- **GoF原定义**：*"定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。"*
- **别名**：虚拟构造器 (Virtual Constructor)
- **核心**：将对象创建延迟到子类

##### 产品 (Product)
- **定义**：工厂方法所创建的对象的共同接口
- **作用**：定义工厂方法所创建的对象的接口

##### 创建者 (Creator)
- **定义**：声明工厂方法的类，该方法返回一个Product类型的对象
- **职责**：可能包含调用工厂方法的缺省实现

##### 延迟实例化 (Deferred Instantiation)
- **定义**：将对象的实例化延迟到子类中进行
- **好处**：提高系统的灵活性和可扩展性

#### 参与者概念

##### 抽象产品 (Abstract Product)
- **定义**：定义产品的接口，是工厂方法所创建的对象的超类型
- **作用**：为具体产品定义公共接口

##### 具体产品 (Concrete Product)
- **定义**：实现Product接口的具体类
- **特点**：是工厂方法的实际创建目标

##### 抽象创建者 (Abstract Creator)
- **定义**：声明工厂方法的抽象类或接口
- **包含**：工厂方法的声明，可能包含调用工厂方法的模板方法

##### 具体创建者 (Concrete Creator)
- **定义**：实现工厂方法的具体类
- **职责**：重定义工厂方法以返回一个具体产品实例

### 3. 抽象工厂模式 (Abstract Factory)

#### 核心概念

##### 抽象工厂模式定义
- **GoF原定义**：*"提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。"*
- **别名**：Kit模式
- **核心**：创建产品族，保证产品的一致性

##### 产品族 (Product Family)
- **定义**：一组相关的产品对象，这些产品对象被设计成一起工作
- **特点**：同一产品族的产品具有相同的约束和依赖关系
- **例子**：Windows风格的按钮、文本框、滚动条

##### 产品等级结构 (Product Hierarchy)
- **定义**：产品的继承层次结构
- **特点**：不同产品族中的同类产品构成产品等级结构
- **例子**：按钮的等级结构：抽象按钮 -> Windows按钮、Mac按钮

##### 产品一致性 (Product Consistency)
- **定义**：确保创建的产品属于同一产品族
- **重要性**：保证产品间的兼容性和协调性

### 4. 建造者模式 (Builder)

#### 核心概念

##### 建造者模式定义
- **GoF原定义**：*"将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。"*
- **核心思想**：分步骤构建复杂对象
- **目的**：使构建过程和表示分离

##### 建造者 (Builder)
- **定义**：为创建一个Product对象的各个部件指定抽象接口
- **职责**：定义构造产品各个部分的抽象方法

##### 指挥者 (Director)
- **定义**：构造一个使用Builder接口的对象
- **职责**：控制构造过程，调用建造者的方法来构造产品

##### 产品 (Product)
- **定义**：表示被构造的复杂对象
- **特点**：包含定义组成部件的类，包括将这些部件装配成最终产品的接口

##### 分步构造 (Step-by-Step Construction)
- **定义**：将复杂对象的构造过程分解为多个步骤
- **优点**：可以精确控制构造过程

### 5. 原型模式 (Prototype)

#### 核心概念

##### 原型模式定义
- **GoF原定义**：*"用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。"*
- **核心思想**：通过复制现有对象来创建新对象
- **适用场景**：当创建新对象的代价比较大时

##### 原型 (Prototype)
- **定义**：声明一个克隆自身的接口
- **作用**：作为创建对象的样板

##### 克隆 (Clone)
- **定义**：创建对象的副本
- **Java中的定义**：Object类的clone()方法

##### 原型管理器 (Prototype Manager)
- **定义**：存储和管理原型对象的注册表
- **职责**：提供原型的注册、注销和获取功能

#### 克隆概念

##### 浅拷贝 (Shallow Copy)
- **定义**：只复制对象的基本类型字段，对象类型字段只复制引用
- **特点**：快速但可能导致共享状态问题
- **Java实现**：Object.clone()的默认行为

##### 深拷贝 (Deep Copy)
- **定义**：递归复制对象的所有字段，包括对象类型字段
- **特点**：完全独立的副本，但性能开销大
- **实现方式**：序列化、手动实现

##### 序列化克隆 (Serialization Clone)
- **定义**：通过序列化和反序列化实现深拷贝
- **优点**：简单易实现
- **缺点**：性能较差，要求对象可序列化

## 第三部分：结构型模式概念

### 1. 适配器模式 (Adapter)

#### 核心概念

##### 适配器模式定义
- **GoF原定义**：*"将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。"*
- **别名**：包装器 (Wrapper)
- **核心**：接口转换，使不兼容的接口能够协同工作

##### 目标接口 (Target)
- **定义**：客户所期待的接口
- **作用**：定义客户使用的与特定领域相关的接口

##### 适配者 (Adaptee)
- **定义**：需要适配的已存在的接口
- **特点**：定义了一个已经存在的接口，这个接口需要适配

##### 适配器 (Adapter)
- **定义**：对Adaptee的接口与Target接口进行适配
- **职责**：将Adaptee的接口转换为Target接口

##### 接口转换 (Interface Conversion)
- **定义**：将一种接口转换为另一种接口的过程
- **目的**：解决接口不兼容问题

#### 实现概念

##### 类适配器 (Class Adapter)
- **定义**：通过继承来实现适配
- **特点**：使用多重继承，适配器继承Target和Adaptee
- **限制**：需要语言支持多重继承

##### 对象适配器 (Object Adapter)
- **定义**：通过组合来实现适配
- **特点**：适配器包含一个Adaptee实例
- **优点**：更灵活，支持单继承语言

##### 双向适配器 (Two-Way Adapter)
- **定义**：支持双向转换的适配器
- **特点**：既可以将Adaptee接口转换为Target接口，也可以反向转换

##### 缺省适配器 (Default Adapter)
- **定义**：为接口提供缺省实现的适配器
- **用途**：当不需要实现接口的所有方法时使用

### 2. 桥接模式 (Bridge)

#### 核心概念

##### 桥接模式定义
- **GoF原定义**：*"将抽象部分与它的实现部分分离，使它们都可以独立地变化。"*
- **别名**：Handle/Body模式
- **核心**：分离抽象和实现，使两者可以独立变化

##### 抽象 (Abstraction)
- **定义**：定义抽象类的接口，维护一个指向Implementor类型对象的指针
- **职责**：定义基于基本操作的较高层次的操作

##### 实现 (Implementation)
- **定义**：定义实现类的接口，该接口不一定要与Abstraction的接口完全一致
- **特点**：一般来讲，Implementor接口仅提供基本操作

##### 分离变化 (Separate Variations)
- **定义**：将两个独立变化的维度分离开来
- **好处**：避免在众多对象间形成静态的继承关系

#### 参与者概念

##### 扩展抽象 (Refined Abstraction)
- **定义**：扩充由Abstraction定义的接口
- **作用**：提供更具体的抽象

##### 具体实现 (Concrete Implementor)
- **定义**：实现Implementor接口并定义它的具体实现
- **特点**：提供基本操作的具体实现

### 3. 组合模式 (Composite)

#### 核心概念

##### 组合模式定义
- **GoF原定义**：*"将对象组合成树形结构以表示'部分-整体'的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。"*
- **核心思想**：树形结构，统一处理单个对象和组合对象
- **目的**：让客户端统一处理个别对象以及对象容器

##### 组件 (Component)
- **定义**：为组合中的对象声明接口，在适当情况下实现所有类共有接口的缺省行为
- **职责**：声明一个接口用于访问和管理Component的子组件

##### 叶子 (Leaf)
- **定义**：在组合中表示叶子节点对象，叶子节点没有子节点
- **特点**：定义组合中基元对象的行为

##### 容器 (Composite)
- **定义**：定义有枝节点行为，用来存储子组件
- **职责**：实现与子组件有关的操作

##### 递归结构 (Recursive Structure)
- **定义**：组合模式的树形结构具有递归特性
- **特点**：容器可以包含叶子，也可以包含其他容器

#### 实现概念

##### 透明方式 (Transparency)
- **定义**：在Component中声明所有用来管理子对象的方法
- **优点**：客户端无需区分叶子和容器
- **缺点**：叶子节点也会有管理子对象的方法

##### 安全方式 (Safety)
- **定义**：在Composite中声明所有用来管理子对象的方法
- **优点**：类型安全
- **缺点**：客户端需要区分叶子和容器

### 4. 装饰器模式 (Decorator)

#### 核心概念

##### 装饰器模式定义
- **GoF原定义**：*"动态地给一个对象添加一些额外的职责。就增加功能来说，Decorator模式相比生成子类更为灵活。"*
- **别名**：包装器 (Wrapper)
- **核心**：动态地给对象添加职责，比继承更灵活

##### 组件 (Component)
- **定义**：定义一个对象接口，可以给这些对象动态地添加职责
- **作用**：为具体组件和装饰器定义公共接口

##### 装饰 (Decoration)
- **定义**：在不改变接口的前提下扩展对象功能
- **特点**：保持接口一致性，支持透明扩展

##### 装饰链 (Decoration Chain)
- **定义**：多个装饰器的组合形成的链式结构
- **特点**：可以任意组合装饰器

#### 参与者概念

##### 具体组件 (Concrete Component)
- **定义**：定义一个对象，可以给这个对象添加一些职责
- **特点**：实现Component接口的基本对象

##### 装饰器 (Decorator)
- **定义**：维持一个指向Component对象的指针，并定义一个与Component接口一致的接口
- **职责**：将请求转发给组件，并可能在转发前后执行一些附加动作

##### 具体装饰器 (Concrete Decorator)
- **定义**：向组件添加职责的具体装饰器
- **特点**：实现具体的装饰功能

### 5. 外观模式 (Facade)

#### 核心概念

##### 外观模式定义
- **GoF原定义**：*"为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。"*
- **核心思想**：提供统一的高层接口，隐藏子系统复杂性
- **目的